/**
 * Copyright (c) 2023 Anthony Mugendi
 *
 * This software is released under the MIT License.
 * https://opensource.org/licenses/MIT
 */

const path = require('path');
const fs = require('fs-extra');
const os = require('os');
const logger = require('debug-symbols')('db-base');

// check the available memory
const defaultBackupDir = path.join(os.homedir(), 'db-state');

const dataChangeHooks = [
    'afterCreate',
    'afterDestroy',
    'afterUpdate',
    'afterSave',
    'afterUpsert',
    'afterBulkUpdate',
    'afterBulkDestroy',
    'afterBulkCreate',
];

class DbState {
    constructor({ backupDir = defaultBackupDir, maxModelFiles = 10 } = {}) {
        // ensure directory
        fs.ensureDirSync(backupDir);
        this.backupDir = backupDir;
        this.maxModelFiles = 10;
        this.busyRestoring = {};
    }

    __is_model(model) {
        return 'tableName' in model;
    }

    __validate_models(models) {
        // if model is passed
        if (this.__is_model(models)) {
            models = [models];
        } else if (typeof models !== 'object') {
            throw new Error(
                'watch() expects a sequelize model, array of models or the sequelize.models object!'
            );
        }

        return models;
    }

    async __hook_model(model) {
        let self = this;

        try {
            for (let hook of dataChangeHooks) {
                model[hook](async (data, options) => {
                    await self.__save_state(hook, model, data);
                });
            }
        } catch (error) {
            throw error;
        }
    }

    __get_model_paths(model) {
        const { dialect } = model.sequelize.options;
        const { database, host, port } = model.sequelize.config;

        this.database = database;
        this.host = host;
        this.port = port;
        this.dialect = dialect

        // unique model identifier to use in logs
        this.model_id=`${this.dialect} ${this.database}.${model.tableName}`

        const dateNow = new Date().toISOString();
        const backupFileName = `${dateNow}.json`;
        const modelDir = path.join(
            this.backupDir,
            dialect,
            database,
            model.tableName
        );
        const backupFilePath = path.join(modelDir, backupFileName);

        return { modelDir, backupFilePath };
    }

    __filter_attributes(model) {
        // TODO:
        /**
         * Should we filter out certain attributes based in values like if they are autogenerated??
         */
        console.log(model.tableAttributes);
        // get attributes
        let attributes = [],
            attrConfig;

        for (let name in model.tableAttributes) {
            attrConfig = model.tableAttributes[name];
            console.log(attrConfig);
        }
    }


    async __save_state(hook, model, data) {
        // console.log({hook, model, data}, this.busyRestoring[model.tableName]);

        try {
            // ignore hooks during model restoration
            if (this.busyRestoring[model.tableName]) return;

            logger.debug(`Saving backup for "${this.model_id}" ~ ${hook}`);

            // get paths
            const { backupFilePath, modelDir } = this.__get_model_paths(model);

            // ensure file
            await fs.ensureDir(modelDir);

            // get all records
            const resp = await model.findAll({ raw: true });

            // write to file
            fs.writeJSON(backupFilePath, resp);

            // console.log(Object.keys(model));
        } catch (error) {
            throw error;
        }
    }

    watch(models) {
        models = this.__validate_models(models);

        for (let i in models) {
            if (!this.__is_model(models[i])) {
                throw new Error(
                    'watch() expects a sequelize model, array of models or the sequelize.models object!'
                );
            }

            this.__hook_model(models[i]).catch((err) => {
                throw err;
            });
        }
    }

    async __get_model_files(modelDir) {
        try {
            // read all files
            let modelFiles = await fs.readdir(modelDir);

            // sort
            modelFiles.sort();

            // clean out old files, keep only 10
            const filesToPrune = modelFiles.slice(0, -1 * this.maxModelFiles);

            for (let f of filesToPrune) {
                f = path.join(modelDir, f);
                // remove without waiting
                fs.remove(f).catch(console.error);
            }

            return modelFiles;
        } catch (error) {
            throw error;
        }
    }

    async __restore_model(model) {
        try {
            // get model paths
            const { modelDir } = this.__get_model_paths(model);

            // console.log({backupFilePath});
            if (!(await fs.exists(modelDir))) return;

            // get model files...
            // this will also clean old model files
            let modelFiles = await this.__get_model_files(modelDir);

            // sort
            modelFiles.sort();

            // if we have no files
            if (modelFiles.length == 0) return;

            logger.debug(`Restoring backup for "${this.model_id}"`);

            let latestBackupFile = modelFiles[modelFiles.length - 1];
            // make absolute path
            latestBackupFile = path.join(modelDir, latestBackupFile);

            // read file data
            const records = await fs.readJson(latestBackupFile);

            // indicate that we are busy restoring...
            this.busyRestoring[model.tableName] = true;

            // bulk create with ignoreDuplicates
            const resp = await model.bulkCreate(records, {
                ignoreDuplicates: true,
            });

            // release busyRestoring flag
            delete this.busyRestoring[model.tableName];

            logger.success(`Model restoration done!`);

            // isNewRecord
        } catch (error) {
            throw error;
        }
    }

    async restore(models) {
        try {
            models = this.__validate_models(models);

            for (let i in models) {
                await this.__restore_model(models[i]);
            }
        } catch (error) {
            throw error;
        }
    }
}

module.exports = DbState;
